"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»
"""
import math
import timeit

def easy(i):
    c = 1
    n = 2
    while c <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if c == i:
                break
            c += 1
        n += 1
    return n

def erato (n):
    n_orig = n
    """
    По закону распределения простых чисел Гауса с поправкой Лежандра 
    чисел приблизительно x / (ln(x) – 1,08366)
    Для поиска объема необходимой выборки надо пользоваться W-функцией Ламберта, что очень затратно.
    Воспользовался конечным автоматом по нескольким известным парам (диапазон - коэффициент)
    Им же ввел ограничение на максимальное искомое число, чтобы не было ошибки переполнения памяти
    """

    tab = list(zip((168, 1229, 9592, 78498, 664579, 5761455, 24400000), (6, 9, 11, 13, 15, 18, 19)))
    for t in tab:
        if n < t[0]:
            n *= t[1]
            break
    if n == n_orig: return -1
    # только для нечетных чисел
    r = [False] * (n // 2 + 1)
    c = 1 # счетчик найденных чисел
    # Наименьший делитель числа не больше чем корень из этого числа.
    l = int(math.sqrt(n) // 2)
    for i in range(1, l):
        if r[i] == False:
            c += 1
            step = i * 2 + 1
            r[i + step : : step] = [True] * len(r[i + step : : step])
    # дальше идем по оставшейся части последовательности и ещем нужное по порядку число
    for i in range(l, n):
        if r[i] == False:
            c += 1
            if c == n_orig: return i * 2 + 1
    return 0
    """"
    Можно добавить сигментацию, чтобы увеличить кратно максимальный объем выборки
    """

# Даже для 1000 числа "простому" алгоритму требуется значительное время
# Для подсчета максимально допустимого для алгоритма Эратосфена числа нужно не больше минуты
print('  Число Просто Эратосфен')
for i in range(1,10):
    n = 10 * i
    print("%+7s" % n, round(timeit.timeit("easy(n)", setup="from __main__ import easy, n", number=10), 4), round(timeit.timeit("erato(n)", setup="from __main__ import erato, n", number=10),4))
for i in range(1,11):
    n = 100 * i
    print("%+7s" % n, round(timeit.timeit("easy(n)", setup="from __main__ import easy, n", number=10), 4), round(timeit.timeit("erato(n)", setup="from __main__ import erato, n", number=10),4))
for i in range (4, 7):
    n = 10 ** i
    print("%+7s" % n, " ---- ", round(timeit.timeit("erato(n)", setup="from __main__ import erato, n", number=10), 4))


"""
Сложность простого алгоритма O(n ** 2)
Сложность решета Эратосфена O(n * log(log n))

  Число Просто Эратосфен
     10 0.0004 0.0001
     20 0.0017 0.0001
     30 0.0038 0.0002
     40 0.0071 0.0002
     50 0.0126 0.0006
     60 0.0167 0.0003
     70 0.0234 0.0004
     80 0.0314 0.0004
     90 0.0394 0.0004
    100 0.0591 0.0005
    200 0.2303 0.0011
    300 0.6329 0.0017
    400 1.0224 0.0022
    500 1.7446 0.0029
    600 2.5227 0.0036
    700 3.6259 0.004
    800 4.8661 0.0047
    900 6.5435 0.0052
   1000 7.8104 0.006
  10000  ----  0.0783
 100000  ----  0.9968
1000000  ----  13.8984

Алгоритм Эратосфена показывает эффективность скорости выполнения при любом требуемом по порядку простому числу. 
Но рационально его будет использовать только при необходимости многократно находить числа больше 1000, 
    поскольку реализация значительно усложняется  
"""


